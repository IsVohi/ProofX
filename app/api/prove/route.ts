
import { NextRequest, NextResponse } from "next/server";
// Force CommonJS import for snarkjs to avoid ESM issues in Next.js API routes
const snarkjs = require("snarkjs");
import { ethers } from "ethers";
// Import embedded ZK artifacts (generated by scripts/bundle-zk.js)
import { COMPLIANCE_WASM_B64, CIRCUIT_ZKEY_B64 } from "@/lib/zkArtifacts";

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONFIG
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Increase timeout for ZK proof generation (Vercel/Next.js specific export)
export const maxDuration = 60;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TYPES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface ProofInput {
    assets: string;
    liabilities: string;
    threshold: string;
    institutionId?: string;
    metric?: string;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ZK GENERATION LOGIC
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function generateRealProof(input: ProofInput) {
    console.log("ðŸ”„ Starting generateRealProof...");
    const assets = BigInt(input.assets);
    const liabilities = BigInt(input.liabilities);
    const threshold = BigInt(input.threshold);

    // Compliance Check
    if (assets < liabilities) throw new Error("Assets must be >= Liabilities");
    if ((assets - liabilities) <= threshold) throw new Error("Capital adequacy check failed");

    const circuitInputs = {
        assets: input.assets,
        liabilities: input.liabilities,
        threshold: input.threshold
    };

    const startTime = Date.now();

    console.log("âš¡ Calling snarkjs.groth16.fullProve with embedded artifacts...");

    // Decode Base64 to Buffers (Pure memory operation, no FS needed)
    const wasmBuff = Buffer.from(COMPLIANCE_WASM_B64, 'base64');
    const zkeyBuff = Buffer.from(CIRCUIT_ZKEY_B64, 'base64');

    // Generate Proof
    let proofResult;
    try {
        proofResult = await snarkjs.groth16.fullProve(
            circuitInputs,
            new Uint8Array(wasmBuff),
            new Uint8Array(zkeyBuff)
        );
        console.log("âœ… snarkjs.groth16.fullProve completed!");
    } catch (err: any) {
        console.error("âŒ snarkjs execution failed:", err);
        throw new Error(`SnarkJS Error: ${err.message}`);
    }

    const { proof, publicSignals } = proofResult;
    const proofTime = Date.now() - startTime;

    // Format for Contract
    const formattedProof = {
        a: [proof.pi_a[0], proof.pi_a[1]],
        b: [
            [proof.pi_b[0][1], proof.pi_b[0][0]],
            [proof.pi_b[1][1], proof.pi_b[1][0]]
        ],
        c: [proof.pi_c[0], proof.pi_c[1]]
    };

    // Generate Commitment
    const commitment = ethers.keccak256(
        ethers.AbiCoder.defaultAbiCoder().encode(
            ['uint256[2]', 'uint256[2][2]', 'uint256[2]', 'uint256'],
            [formattedProof.a, formattedProof.b, formattedProof.c, publicSignals[0]]
        )
    );

    return { formattedProof, publicSignals, commitment, proofTime };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// API ROUTE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function POST(req: NextRequest) {
    try {
        const body: ProofInput = await req.json();
        console.log("ðŸ“ API Prover: Request received", { entity: body.institutionId });

        console.log("ðŸ” Generating REAL ZK Proof using EMBEDDED artifacts...");

        // No filesystem checks needed!
        const result = await generateRealProof(body);

        return NextResponse.json({
            success: true,
            proof: result.formattedProof,
            publicSignals: result.publicSignals,
            commitment: result.commitment,
            proofTime: result.proofTime,
            mode: "real_zk"
        });

    } catch (error: any) {
        console.error("âŒ Proof generation failed:", error.message);
        return NextResponse.json(
            { success: false, error: error.message || "Proof generation failed" },
            { status: 400 }
        );
    }
}
