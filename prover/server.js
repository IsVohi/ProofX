const express = require('express');
const cors = require('cors');
const { ethers } = require('ethers');
const path = require('path');
const snarkjs = require('snarkjs');
const fs = require('fs');

const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

// Load .env from root directory
require('dotenv').config({ path: path.resolve(__dirname, '../.env') });

const app = express();
const PORT = process.env.PROVER_PORT || 3001;

// ğŸ›¡ï¸ SECURITY MIDDLEWARE
app.use(helmet()); // Secure HTTP headers
app.use(cors());
app.use(express.json({ limit: '10kb' })); // Limit body size

// ğŸš¦ RATE LIMITING
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per window
    standardHeaders: true,
    legacyHeaders: false,
    message: { error: "Too many requests, please try again later." }
});
app.use(limiter);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ZK CIRCUIT ARTIFACTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// These paths point to the compiled circuit artifacts generated by:
//   1. circom compliance.circom --r1cs --wasm --sym -o build
//   2. snarkjs groth16 setup / contribute / export
//
// The circuit proves: (assets - liabilities) > threshold
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CIRCUIT_WASM_PATH = path.resolve(__dirname, '../circuits/build/compliance_js/compliance.wasm');
const CIRCUIT_ZKEY_PATH = path.resolve(__dirname, '../circuits/build/circuit_final.zkey');

// Verify circuit artifacts exist on startup
function verifyCircuitArtifacts() {
    const wasmExists = fs.existsSync(CIRCUIT_WASM_PATH);
    const zkeyExists = fs.existsSync(CIRCUIT_ZKEY_PATH);

    if (!wasmExists || !zkeyExists) {
        console.error('âš ï¸  WARNING: ZK circuit artifacts not found!');
        console.error('   WASM:', wasmExists ? 'âœ…' : 'âŒ', CIRCUIT_WASM_PATH);
        console.error('   ZKEY:', zkeyExists ? 'âœ…' : 'âŒ', CIRCUIT_ZKEY_PATH);
        console.error('   Run: cd circuits && npm run compile && npm run setup');
        return false;
    }
    return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYCHAIN AUTHORIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function verifyKeychainSignature(message, signature, claimedSigner) {
    try {
        const recoveredAddress = ethers.verifyMessage(message, signature);
        const valid = recoveredAddress.toLowerCase() === claimedSigner.toLowerCase();
        return { valid, recoveredAddress, claimedSigner };
    } catch (error) {
        return { valid: false, recoveredAddress: null, claimedSigner, error: error.message };
    }
}

const AUTHORIZED_SIGNERS = new Set([]);

function isAuthorizedSigner(address) {
    if (AUTHORIZED_SIGNERS.size === 0) return true;
    return AUTHORIZED_SIGNERS.has(address.toLowerCase());
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REAL ZK PROOF GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// This function generates a REAL Groth16 ZK proof using snarkjs.
//
// FLOW:
// 1. Accept private inputs (assets, liabilities) and public input (threshold)
// 2. Generate witness from the compiled WASM circuit
// 3. Create Groth16 proof using the circuit's proving key (zkey)
// 4. Return proof elements (a, b, c) and public signals
//
// The proof can be verified on-chain by Groth16Verifier.sol
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Generate a real ZK proof using snarkjs.fullProve()
 * 
 * @param {Object} privateInputs - Private inputs (never revealed)
 * @param {string} privateInputs.assets - Total assets (as string to preserve precision)
 * @param {string} privateInputs.liabilities - Total liabilities
 * @param {Object} publicInputs - Public inputs (visible on-chain)
 * @param {string} publicInputs.threshold - Minimum capital requirement
 * @returns {Promise<{ proof, publicSignals, formattedProof }>}
 */
async function generateRealProof(privateInputs, publicInputs) {
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // STEP 1: Validate inputs
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const assets = BigInt(privateInputs.assets);
    const liabilities = BigInt(privateInputs.liabilities);
    const threshold = BigInt(publicInputs.threshold);

    // Pre-check: assets >= liabilities (prevents circuit failure)
    if (assets < liabilities) {
        throw new Error('UNDERFLOW: Assets must be >= Liabilities');
    }

    // Pre-check: capital > threshold (compliance check)
    const capital = assets - liabilities;
    if (capital <= threshold) {
        throw new Error(`NON_COMPLIANT: Capital (${capital}) must be > Threshold (${threshold})`);
    }

    console.log('ğŸ“Š Proof inputs validated:');
    console.log('   Assets:      ', assets.toString());
    console.log('   Liabilities: ', liabilities.toString());
    console.log('   Capital:     ', capital.toString());
    console.log('   Threshold:   ', threshold.toString());
    console.log('   Compliant:   ', capital > threshold);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // STEP 2: Prepare circuit inputs
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const circuitInputs = {
        assets: privateInputs.assets,
        liabilities: privateInputs.liabilities,
        threshold: publicInputs.threshold
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // STEP 3: Generate proof using snarkjs.fullProve()
    // This performs:
    //   - Witness generation (computes all intermediate signals)
    //   - Proof generation (creates Groth16 proof elements)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    console.log('ğŸ” Generating Groth16 proof...');
    const startTime = Date.now();

    const { proof, publicSignals } = await snarkjs.groth16.fullProve(
        circuitInputs,
        CIRCUIT_WASM_PATH,
        CIRCUIT_ZKEY_PATH
    );

    const proofTime = Date.now() - startTime;
    console.log(`âœ… Proof generated in ${proofTime}ms`);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // STEP 4: Format proof for Solidity verifier
    // The Groth16Verifier.sol expects:
    //   - uint[2] _pA (G1 point)
    //   - uint[2][2] _pB (G2 point - note the coordinate ordering!)
    //   - uint[2] _pC (G1 point)
    //   - uint[1] _pubSignals
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const formattedProof = {
        a: [proof.pi_a[0], proof.pi_a[1]],
        // G2 point requires coordinate swap for Solidity
        b: [
            [proof.pi_b[0][1], proof.pi_b[0][0]],
            [proof.pi_b[1][1], proof.pi_b[1][0]]
        ],
        c: [proof.pi_c[0], proof.pi_c[1]]
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // STEP 5: Create commitment hash for on-chain reference
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const commitment = ethers.keccak256(
        ethers.AbiCoder.defaultAbiCoder().encode(
            ['uint256[2]', 'uint256[2][2]', 'uint256[2]', 'uint256'],
            [formattedProof.a, formattedProof.b, formattedProof.c, publicSignals[0]]
        )
    );

    return {
        proof,               // Raw snarkjs proof object
        publicSignals,       // Array of public signals [threshold]
        formattedProof,      // Formatted for Solidity
        commitment,          // Hash for on-chain reference
        proofTime            // Generation time in ms
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FALLBACK: Simulated proof for when circuit artifacts are missing
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function generateSimulatedProof(input) {
    if (!input.institutionId || !input.metric || !input.value || !input.threshold) {
        throw new Error("Invalid inputs: Missing required fields");
    }

    const isCompliant = Number(input.value) >= Number(input.threshold);
    if (!isCompliant) {
        throw new Error("Compliance check failed: Value below threshold");
    }

    // Generate mock proof structure that matches real format
    const mockProof = {
        a: ['0x' + '1'.repeat(64), '0x' + '2'.repeat(64)],
        b: [
            ['0x' + '3'.repeat(64), '0x' + '4'.repeat(64)],
            ['0x' + '5'.repeat(64), '0x' + '6'.repeat(64)]
        ],
        c: ['0x' + '7'.repeat(64), '0x' + '8'.repeat(64)]
    };
    const publicSignals = [input.threshold.toString()];

    // CRITICAL FIX: Hash the PROOF STRUCTURE, not the input JSON.
    // This matches the Contract's expectations: hash(pA, pB, pC, pubSignals)
    const commitment = ethers.keccak256(
        ethers.AbiCoder.defaultAbiCoder().encode(
            ['uint256[2]', 'uint256[2][2]', 'uint256[2]', 'uint256'],
            [mockProof.a, mockProof.b, mockProof.c, publicSignals[0]]
        )
    );

    return {
        formattedProof: mockProof,
        publicSignals: publicSignals,
        commitment,
        simulated: true
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROUTES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

app.get('/', (req, res) => {
    const artifactsReady = verifyCircuitArtifacts();
    res.json({
        service: "ProofX Prover Node",
        status: "active",
        mode: artifactsReady ? "real_zk" : "simulated_zk",
        keychain: "enabled",
        circuit: {
            ready: artifactsReady,
            wasm: CIRCUIT_WASM_PATH,
            zkey: CIRCUIT_ZKEY_PATH
        }
    });
});

/**
 * POST /prove
 * 
 * Generate a REAL ZK proof for capital adequacy compliance.
 * 
 * Request Body:
 * {
 *   "assets": "1000000",       // Private: Total assets
 *   "liabilities": "400000",   // Private: Total liabilities  
 *   "threshold": "500000",     // Public: Minimum capital requirement
 *   "institutionId": "...",    // Metadata for logging
 *   "metric": "capital_adequacy"
 * }
 * 
 * Response:
 * {
 *   "success": true,
 *   "proof": { a, b, c },
 *   "publicSignals": ["500000"],
 *   "commitment": "0x...",
 *   "proofTime": 1234
 * }
 */
app.post('/prove', async (req, res) => {
    try {
        const input = req.body;
        console.log("ğŸ“ Received proof request:", input.institutionId, input.metric);
        console.log("   ğŸ“Š Input check - assets:", input.assets, "liabilities:", input.liabilities, "threshold:", input.threshold);

        // Check if we have real circuit artifacts
        const useRealZK = verifyCircuitArtifacts();
        console.log("   ğŸ” Circuit artifacts ready:", useRealZK);

        if (useRealZK && input.assets && input.liabilities && input.threshold) {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // REAL ZK PROOF PATH
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            console.log("ğŸ” Using REAL ZK proof generation...");

            const result = await generateRealProof(
                { assets: input.assets, liabilities: input.liabilities },
                { threshold: input.threshold }
            );

            res.json({
                success: true,
                proof: result.formattedProof,
                publicSignals: result.publicSignals,
                commitment: result.commitment,
                proofTime: result.proofTime,
                mode: 'real_zk',
                details: {
                    algorithm: "groth16",
                    curve: "bn128",
                    timestamp: Date.now()
                }
            });

        } else {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SIMULATED PROOF PATH (fallback)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            console.log("âš ï¸  Using SIMULATED proof (circuit not ready or legacy input format)");

            const result = generateSimulatedProof(input);

            res.json({
                success: true,
                proof: result.formattedProof,
                publicSignals: result.publicSignals,
                commitment: result.commitment,
                mode: 'simulated_zk',
                details: {
                    algorithm: "mock-groth16-simulation",
                    timestamp: Date.now()
                }
            });
        }

    } catch (error) {
        console.error("âŒ Proof generation failed:", error.message);
        res.status(400).json({
            success: false,
            error: error.message
        });
    }
});

/**
 * POST /prove-real
 * 
 * DEDICATED endpoint for real ZK proofs only.
 * Will fail if circuit artifacts are not available.
 */
app.post('/prove-real', async (req, res) => {
    try {
        const { assets, liabilities, threshold } = req.body;

        if (!assets || !liabilities || !threshold) {
            return res.status(400).json({
                success: false,
                error: "Missing required fields: assets, liabilities, threshold"
            });
        }

        if (!verifyCircuitArtifacts()) {
            return res.status(503).json({
                success: false,
                error: "ZK circuit not ready. Run trusted setup first."
            });
        }

        console.log("ğŸ” Generating REAL ZK proof...");

        const result = await generateRealProof(
            { assets, liabilities },
            { threshold }
        );

        res.json({
            success: true,
            proof: result.formattedProof,
            publicSignals: result.publicSignals,
            commitment: result.commitment,
            proofTime: result.proofTime
        });

    } catch (error) {
        console.error("âŒ Real proof generation failed:", error.message);
        res.status(400).json({
            success: false,
            error: error.message
        });
    }
});

/**
 * POST /verify-authorization
 * Verifies Keychain signature for proof submission authorization.
 */
app.post('/verify-authorization', (req, res) => {
    try {
        const { commitment, signature, signerAddress } = req.body;

        if (!commitment || !signature || !signerAddress) {
            return res.status(400).json({
                authorized: false,
                error: "Missing required fields: commitment, signature, signerAddress"
            });
        }

        console.log("ğŸ” Verifying Keychain authorization...");

        const message = `ProofX Authorization\n\nCommitment: ${commitment}\nTimestamp: ${req.body.signatureTimestamp || 'unknown'}`;
        const verification = verifyKeychainSignature(message, signature, signerAddress);

        if (!verification.valid) {
            return res.status(401).json({
                authorized: false,
                error: "Signature verification failed",
                recoveredAddress: verification.recoveredAddress
            });
        }

        if (!isAuthorizedSigner(verification.recoveredAddress)) {
            return res.status(403).json({
                authorized: false,
                error: "Signer not authorized"
            });
        }

        console.log("âœ… Keychain authorization verified:", verification.recoveredAddress);

        res.json({
            authorized: true,
            recoveredAddress: verification.recoveredAddress,
            timestamp: Date.now()
        });

    } catch (error) {
        console.error("âŒ Authorization error:", error);
        res.status(500).json({ authorized: false, error: "Internal error" });
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// START SERVER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

app.listen(PORT, () => {
    const artifactsReady = verifyCircuitArtifacts();

    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ProofX Prover Node (ZK-Enabled)                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  ğŸš€ Service running on: http://localhost:${PORT}
  ğŸ“¡ Endpoints:
     POST /prove       - Generate proof (auto-selects real/simulated)
     POST /prove-real  - Generate REAL ZK proof only
     POST /verify-authorization - Verify Keychain signature
  
  ğŸ” ZK Status: ${artifactsReady ? 'âœ… REAL PROOFS ENABLED' : 'âš ï¸  SIMULATED MODE'}
  ğŸ›¡ï¸  Authorization: Keychain (EIP-191)
    `);
});
